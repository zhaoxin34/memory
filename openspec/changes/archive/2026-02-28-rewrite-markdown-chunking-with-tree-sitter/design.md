## Context

当前 Markdown 分块使用正则表达式解析，存在以下问题：
1. 表格（`|` 分隔的 Markdown 表格）无法识别，被当作普通段落处理
2. 嵌套列表（缩进列表）结构丢失
3. 块引用（`>` 开头）嵌套时处理不当
4. 语义合并按字符数机械切分，可能切断句子

需要基于 tree-sitter 的语法树解析能力，实现语义正确的分块。

## Goals / Non-Goals

**Goals:**
- 使用 tree-sitter 准确解析 Markdown 语法树
- 正确识别和处理：表格、列表（含嵌套）、块引用、代码块、标题层级
- 保证分块不切断语义单元（句子、列表项、表格行）
- 保持与现有配置（chunk_size、overlap）的兼容性

**Non-Goals:**
- 不处理非 Markdown 格式（HTML、PDF 等）
- 不实现 LLM 级别的语义理解
- 不改变 Chunk 数据模型结构

## Decisions

### D1: 使用 tree-sitter-markdown 而非 markdown-it-py

| 方案 | 优点 | 缺点 |
|-----|------|------|
| tree-sitter-markdown | 真正的语法树，结构准确，支持增量解析 | 需要单独安装语言包 |
| markdown-it-py | 成熟稳定，生态丰富 | 基于插件，不是真正的语法树 |
| 正则表达式（当前） | 无额外依赖 | 准确度差 |

**决定**: 使用 tree-sitter-markdown。语法树结构比 AST 更准确，能正确处理嵌套和复杂结构。

### D2: 分块策略 - 自底向上合并

```
语法树节点 → 语义单元提取 → 按 target_size 合并 → 生成最终 chunks
```

- 步骤1：遍历语法树，提取语义节点（section、paragraph、list_item、table_row 等）
- 步骤2：计算每个节点的字符数
- 步骤3：从最小的语义单元开始，合并直到达到 target_size
- 步骤4：保持语义边界（不在 list_item 中间切断）

### D3: 表格处理 - 作为独立语义单元

表格是特殊的语义结构，处理策略：
- 完整表格（表头+多行数据）作为独立 chunk
- 大表格可按行拆分，但保留表头
- 使用 `table` 节点类型识别

### D4: 代码块处理 - 按语言分组

- 连续的语言标记代码块作为一组
- 大代码块可按函数/类边界拆分（通过空白行检测）
- 在 metadata 中标记 `chunk_type: "code"`

### D5: 与现有配置的兼容

保持 `ChunkingConfig` 接口不变：
- `chunk_size`: 目标大小（字符数）
- `chunk_overlap`: 重叠大小（用于保持上下文）
- `min_chunk_size`: 最小块大小（过滤噪声）

tree-sitter 分块会尽量保证语义完整，超出部分正常处理。

## Risks / Trade-offs

| 风险 | 影响 | 缓解措施 |
|-----|------|---------|
| tree-sitter 解析错误 | 分块失败 | 降级到原始固定大小分块 |
| 大文档性能 | 解析慢 | 使用增量解析，缓存语法树 |
| 新依赖引入 | 包体积增加 | 作为可选依赖，不强制安装 |
| 语法树不稳定 | 升级后行为变化 | 锁定语言包版本 |

## Migration Plan

1. **Phase 1**: 创建 `tree_sitter_chunking.py`，实现基础分块
2. **Phase 2**: 修改 `chunking.py` 选择器，默认使用 tree-sitter
3. **Phase 3**: 添加降级逻辑，解析失败时回退
4. **Phase 4**: 移除旧的正则表达式代码

部署：平滑升级，旧文档不重新分块，新文档使用新策略。

## Open Questions

- [ ] 嵌套列表的拆分策略：按顶级项拆分还是保留完整嵌套结构？
- [ ] 代码块内的空白行是否作为拆分点？
- [ ] 是否需要保留原有正则分块作为后备方案？
