"""Core domain models for the knowledge base system.

These models represent the fundamental entities in the system:
- Repository: A logical container for organizing documents
- Document: A source document (file, webpage, etc.)
- Chunk: A segment of a document suitable for embedding
- Embedding: A vector representation of a chunk
- SearchResult: A retrieved chunk with relevance score
"""

from datetime import datetime
from enum import Enum
from typing import Any, Optional
from uuid import UUID, uuid4

from pydantic import BaseModel, Field, field_validator


class Repository(BaseModel):
    """A repository for organizing and isolating document collections.

    Repositories provide logical isolation between different projects or topics,
    ensuring that documents, chunks, and embeddings are kept separate.
    """

    id: UUID = Field(default_factory=uuid4)
    name: str = Field(..., pattern="^[a-z0-9-]+$", description="Repository name (kebab-case)")
    description: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    metadata: dict[str, Any] = Field(default_factory=dict)

    @field_validator("name")
    @classmethod
    def name_not_empty(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("Repository name cannot be empty")
        return v


class DocumentType(str, Enum):
    """Supported document types."""

    MARKDOWN = "markdown"
    PDF = "pdf"
    HTML = "html"
    TEXT = "text"
    UNKNOWN = "unknown"


class Document(BaseModel):
    """A source document in the knowledge base.

    Represents a single document that has been ingested into the system.
    Documents are split into chunks for embedding and retrieval.
    """

    id: UUID = Field(default_factory=uuid4)
    repository_id: UUID = Field(..., description="Repository this document belongs to")
    source_path: str = Field(..., description="Original path or URL of the document")
    doc_type: DocumentType = Field(default=DocumentType.UNKNOWN)
    title: Optional[str] = None
    content: str = Field(..., description="Full text content of the document")
    content_md5: Optional[str] = Field(None, description="MD5 hash of the document content")
    metadata: dict[str, Any] = Field(default_factory=dict)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    @field_validator("content")
    @classmethod
    def content_not_empty(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("Document content cannot be empty")
        return v


class Chunk(BaseModel):
    """A segment of a document suitable for embedding.

    Documents are split into chunks to enable semantic search at a granular level.
    Each chunk maintains a reference to its parent document.
    """

    id: UUID = Field(default_factory=uuid4)
    repository_id: UUID = Field(..., description="Repository this chunk belongs to")
    document_id: UUID = Field(..., description="Parent document ID")
    content: str = Field(..., description="Text content of this chunk")
    chunk_index: int = Field(..., ge=0, description="Position in the document")
    start_char: int = Field(..., ge=0, description="Start character offset in document")
    end_char: int = Field(..., gt=0, description="End character offset in document")
    metadata: dict[str, Any] = Field(default_factory=dict)
    created_at: datetime = Field(default_factory=datetime.utcnow)

    @field_validator("content")
    @classmethod
    def content_not_empty(cls, v: str) -> str:
        if not v or not v.strip():
            raise ValueError("Chunk content cannot be empty")
        return v

    @field_validator("end_char")
    @classmethod
    def end_after_start(cls, v: int, info: Any) -> int:
        if "start_char" in info.data and v <= info.data["start_char"]:
            raise ValueError("end_char must be greater than start_char")
        return v


class Embedding(BaseModel):
    """A vector representation of a chunk.

    Embeddings are generated by an embedding provider and stored in a vector database.
    """

    chunk_id: UUID = Field(..., description="Chunk this embedding represents")
    vector: list[float] = Field(..., description="Embedding vector")
    model: str = Field(..., description="Embedding model used")
    dimension: int = Field(..., gt=0, description="Vector dimension")
    created_at: datetime = Field(default_factory=datetime.utcnow)

    @field_validator("vector")
    @classmethod
    def vector_not_empty(cls, v: list[float]) -> list[float]:
        if not v:
            raise ValueError("Embedding vector cannot be empty")
        return v

    @field_validator("dimension")
    @classmethod
    def dimension_matches_vector(cls, v: int, info: Any) -> int:
        if "vector" in info.data and v != len(info.data["vector"]):
            raise ValueError(f"Dimension {v} does not match vector length {len(info.data['vector'])}")
        return v


class SearchResult(BaseModel):
    """A retrieved chunk with relevance score.

    Returned by the retrieval system, combining chunk content with similarity score.
    """

    chunk: Chunk
    score: float = Field(..., ge=0.0, le=1.0, description="Relevance score (0-1)")
    document: Optional[Document] = None
    metadata: dict[str, Any] = Field(default_factory=dict)

    class Config:
        """Pydantic configuration."""
        arbitrary_types_allowed = True
